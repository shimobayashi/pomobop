# 案2A改: バックグラウンド主導 + ポップアップ表示分離型

## 概要

Chrome拡張機能ポモドーロタイマー（pomobop）において、**バックグラウンドで完全な状態管理を行いつつ、1秒刻みのカウントダウン表示のみポップアップ側で実現する**アーキテクチャ案です。

案2A（バックグラウンド完全主導型）をベースに、Chrome拡張の制約を回避しながら、リアルタイム表示を実現します。

## 基本設計思想

- **バックグラウンド**: 全ての状態管理、ビジネスロジック、確実な完了検知
- **ポップアップ**: 表示専用 + ローカル1秒刻みタイマー
- **通信**: chrome.runtime.sendMessage（コマンド）+ chrome.storage.onChanged（状態同期）+ 30秒定期同期

## アーキテクチャ図

```
┌─────────────────────────────────────────────────────────────┐
│              popup.ts (View + Local Display)               │
├─────────────────────────────────────────────────────────────┤
│ ・1秒刻みローカル表示タイマー（endTime基準計算）              │
│ ・ユーザー操作転送（chrome.runtime.sendMessage）            │
│ ・30秒ごとの表示補正                                        │
│ ・chrome.storage.onChanged監視                             │
└─────────────────┬───────────────────────┬───────────────────┘
                  │                       │
            Commands │                       │ State Updates
      (chrome.runtime.sendMessage)          │ (chrome.storage.onChanged)
                  │                       │ + 30秒同期
                  ▼                       ▲
┌─────────────────────────────────────────────────────────────┐
│           background.ts (Complete State Manager)           │
├─────────────────────────────────────────────────────────────┤
│ ・全ての状態管理（開始時刻ベース）                            │
│ ・chrome.alarms: タイマー完了 + 30秒同期                    │
│ ・セッション遷移ロジック                                    │
│ ・30秒ごとの軽量状態ブロードキャスト                         │
└─────────────────────────────────────────────────────────────┘
```

## 状態管理設計

### バックグラウンド：完全な状態管理
- **時刻ベース状態管理**: 開始時刻、終了予定時刻、一時停止時刻、累積一時停止時間
- **セッション情報**: セッション種別（work/shortBreak/longBreak）、サイクル位置（1-8）
- **制御状態**: 実行状態、最終更新時刻

### ポップアップ：表示専用ローカル状態
- **表示計算用状態**: 表示計算用終了時刻（真実の状態ではない）
- **UI表示用**: 実行状態、セッション種別、サイクル位置

## 責任分担

### background.ts の責任
1. **完全な状態管理**: 全ての状態をメモリ + chrome.storage で管理
2. **chrome.alarms管理**: タイマー完了検知 + 30秒定期同期
3. **セッション遷移**: ポモドーロサイクルのロジック
4. **コマンド処理**: ポップアップからのstart/pause/reset
5. **定期同期**: 30秒ごとの軽量状態ブロードキャスト

### popup.ts の責任
1. **1秒刻み表示**: endTime基準のリアルタイム計算
2. **ユーザー操作**: バックグラウンドへのコマンド転送
3. **状態同期**: chrome.storage.onChanged + 30秒同期の受信
4. **表示更新**: UI要素の更新のみ

## 同期メカニズム

### 1. コマンド送信（popup → background）
- **ポップアップ**: chrome.runtime.sendMessage でコマンド送信
- **バックグラウンド**: onMessage.addListener でSTART/PAUSE/RESETコマンドを処理

### 2. 状態変更時同期（background → popup）
- **バックグラウンド**: chrome.storage.local.set で状態保存・ブロードキャスト
- **ポップアップ**: chrome.storage.onChanged で状態変更を監視・同期

### 3. 30秒定期同期（background → popup）
- **chrome.alarms**: 30秒間隔（0.5分）で定期実行設定
- **軽量同期**: storageを使わずruntime.sendMessageで直接送信
- **エラーハンドリング**: ポップアップ未開時は例外を無視

## 表示更新システム

### ポップアップでの1秒刻み表示
- **表示ループ**: setInterval による1秒間隔の表示更新
- **時間計算**: endTime基準の精密計算（累積誤差なし）
- **表示フォーマット**: MM:SS形式でのリアルタイム表示
- **状態判定**: isRunning状態に応じた適切な表示切り替え

### バックグラウンドでの状態計算
- **endTime基準**: 統一された時刻計算ロジック
- **一時停止対応**: pausedAt時刻での残り時間計算
- **実行状態管理**: isRunning状態に応じた計算分岐
- **精度保証**: Math.ceil による秒単位での正確な計算

## Chrome制約の回避方法

### Service Worker 30秒アイドル停止への対応
- **chrome.alarms活用**: タイマー完了時刻での単発アラーム設定
- **30秒同期のみ**: 状態同期用の定期アラーム（Service Worker延命は副次効果）
- **確実な完了検知**: ブラウザ閉鎖時もchrome.alarmsでタイマー完了を検知

### chrome.runtime.sendMessage 断絶への対応
- **複数同期チャネル**:
  1. メッセージ送信（ポップアップ開いている時）
  2. chrome.storage.onChanged（確実な同期）
  3. 初期化時の状態取得（GET_STATE）

### 表示遅延への対応
- **ローカル表示更新**: 遅延なしの即座な表示計算
- **定期補正**: 30秒ごとの同期で精度確保
- **ズレ検知**: 2秒以上のズレ時に自動補正

## 動作フロー

### 1. タイマー開始時
```
1. ユーザークリック → popup.sendCommand('START_TIMER')
2. background.startTimer() → 状態計算 + chrome.alarms設定
3. chrome.storage.local.set() → popup.syncDisplayState()
4. popup: 1秒刻みローカル表示開始
```

### 2. 実行中
```
1. popup: endTimeから毎秒リアルタイム計算表示
2. background: 30秒ごとに軽量同期メッセージ送信
3. 両方で独立して時間計算（同じendTime基準）
4. 30秒ごとに表示補正で精度確保
```

### 3. 一時停止・再開
```
1. ユーザー操作 → popup.sendCommand('PAUSE_TIMER')
2. background: pausedAt記録 + アラームクリア
3. chrome.storage更新 → popup表示同期
4. 再開時: endTime調整 + アラーム再設定
```

### 4. 完了時
```
1. chrome.alarms発火 → background.handleTimerComplete()
2. 通知タブ表示 + セッション遷移
3. chrome.storage更新 → popup表示同期
4. 新しいセッションでUI更新
```

## メリット

### ✅ **案2Aの堅牢性を維持**
- **バックグラウンドで完全な状態管理**: 単一真実のソース
- **chrome.alarms による確実な完了検知**: ブラウザ閉鎖時も動作
- **セッション遷移の一元管理**: ビジネスロジックが集約

### ✅ **1秒カウントダウン表示を実現**
- **ポップアップで滑らかな表示更新**: 遅延なし
- **endTime基準の精密計算**: 累積誤差なし
- **即座のユーザーフィードバック**: 操作レスポンス良好

### ✅ **Chrome制約を完全回避**
- **30秒同期でService Worker制約回避**: chrome.alarms活用
- **複数同期チャネル**: 断絶に対する冗長性
- **軽量メッセージング**: I/O負荷最小化

### ✅ **高い精度と信頼性**
- **定期補正**: 30秒ごとの同期で表示ズレ防止
- **二重検知システム**: ポップアップ + バックグラウンド
- **状態復元**: ポップアップ再開時の正確な状態同期

## デメリット

### ⚠️ **実装の複雑性**
- **2つの計算系統**: バックグラウンド（真実）+ ポップアップ（表示）
- **同期ロジック**: 複数チャネルの管理が必要
- **状態管理**: 真実の状態 vs 表示用状態の分離

### ⚠️ **軽微な表示ズレ**
- **30秒間隔補正**: 最大1-2秒の表示ズレ可能性
- **ネットワーク遅延**: メッセージパッシングの遅延
- **計算誤差**: 丸め処理による微細な差異

### ⚠️ **Chrome API依存**
- **chrome.runtime.sendMessage**: Service Worker状態に依存
- **chrome.alarms**: システムリソースに依存
- **chrome.storage**: 書き込み/読み込み遅延

### ⚠️ **テスト複雑性**
- **統合テスト**: 2つのコンポーネント間の相互作用
- **タイミング依存**: 非同期処理のテスト
- **モック設定**: Chrome API群の複雑なモック

## 実装時の注意点

### 時刻計算の統一
- **統一計算式**: バックグラウンドとポップアップで同じ計算ロジック使用
- **endTime基準**: 絶対時刻ベースでの一貫した時間計算

### エラーハンドリング
- **メッセージ送信失敗**: Service Worker停止時の例外を適切に処理
- **通信断絶対応**: 複数チャネルでの冗長性確保

### 同期タイミングの調整
- **30秒間隔**: chrome.alarmsの最小値（0.5分）を使用
- **適切な頻度**: パフォーマンスと精度のバランス

### メモリリーク防止
- **ポップアップ閉鎖時**: beforeunloadでsetIntervalクリーンアップ
- **リソース管理**: 適切なライフサイクル管理

## 適用場面

### 案2A改が適している場合
1. **エンタープライズ用途**: 状態の堅牢性が最重要
2. **複数UI対応**: ポップアップ以外のUIも予定
3. **チーム開発**: フロントエンドとバックエンドの分離
4. **スケーラビリティ**: 将来的な機能拡張を見込む
5. **確実性重視**: ブラウザ閉鎖時も確実に動作させたい

### 案2A改が不適切な場合
1. **シンプルなタイマー**: 基本的な機能のみ
2. **小規模チーム**: 1-2人での開発
3. **プロトタイピング**: 迅速な開発・検証が必要
4. **レスポンス性最重視**: 複雑性よりもUXを優先

## 結論

**案2A改は、バックグラウンド主導の堅牢性と1秒刻み表示を両立する技術的に洗練されたアーキテクチャです。**

Chrome拡張の制約を巧みに回避しながら、企業レベルの信頼性とユーザー体験を実現できます。ただし、実装の複雑性とテストの困難さを考慮し、要件に応じて採用を検討する必要があります。

### 主な特徴
- ✅ **Chrome制約の完全回避**: 30秒同期による制約回避
- ✅ **企業レベルの堅牢性**: バックグラウンドでの確実な状態管理
- ✅ **優れたUX**: 1秒刻みの滑らかな表示
- ⚠️ **実装複雑性**: 高度な設計・実装スキル要求

適切な要件と開発リソースがあれば、非常に優秀なアーキテクチャ選択肢となります。